% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/allMethods.R
\name{generateEnrichedHeatmap}
\alias{generateEnrichedHeatmap}
\title{generateEnrichedHeatmap}
\usage{
generateEnrichedHeatmap(object, include_group_annotation = TRUE,
  extra_annotation_columns = NULL, sample_names = NULL,
  return_ht_list = FALSE, ylim = "common_max", decreasing = FALSE,
  all_color_scales_equal = TRUE, matrices_color,
  matrices_pos_line = TRUE, matrices_pos_line_gp = gpar(lty = 2),
  matrices_show_heatmap_legend = TRUE,
  matrices_column_title_gp = gpar(fontsize = 10, fontface = "bold"),
  matrices_axis_name_gp = gpar(fontsize = 8), group_anno_color = NULL,
  group_anno_width = 3, group_anno_row_title_gp = gpar(fontsize = 10),
  group_anno_column_names_gp = gpar(fontsize = 10),
  extra_anno_color = vector(mode = "list", length =
  length(extra_annotation_columns)), extra_anno_top_annotation = TRUE,
  extra_anno_width = (rep(6, length(extra_annotation_columns))),
  only_extra_annotation_columns = FALSE, gap = 2,
  genes_to_label = NULL, gene_label_font_size = 6)
}
\arguments{
\item{object}{A profileplyr object}

\item{include_group_annotation}{If TRUE (default value) then the Heatmap will be grouped based on the range metadata column specified by 'rowGroupsInUse'}

\item{extra_annotation_columns}{A character vector of names that match column names of mcols(object). Extra annotation columns will be added to the heatmap based on the values of these indicated range metadata columns.}

\item{sample_names}{A character vector that will set the names of the heatmap components that are generated from the profileplyr assays() matrices. This argument is optional, by default the names will be the name of the samples in the profileplyr object rownames(sampleData(object)).}

\item{return_ht_list}{Whether the returned object is the heatmap list and not the actual figure. This will be a list of the various components (heatmaps and annotation columns) that can be added to with additional columns in a customized manner.}

\item{ylim}{A numeric vector of two numbers that species the minimum and maximum of the yaxis of all the heatmaps generated for the matrices. The default is to use the max of the heatmap with the highest signal. If ylim = NULL, different ranges will be inferred for each heatmap.}

\item{decreasing}{If object@params$mcolToOrderBy has been changed and is NULL, then the ranges will be ordered by the column indicated in this slot of the metadata. By default, the order will be increasing for the factor or numeric value. For decreasing order, choose decreasing = TRUE.}

\item{all_color_scales_equal}{If TRUE (default value) then the same color scale will be used for each separate heatmap. If FALSE, color scales will be inferred for each heatmap as indicated by the legends.}

\item{matrices_color}{Either a single character vector, a numeric vector, a function call to colorRamp2 from the circlize package, or a list. For anything but a list, all the heatmaps generated for the matrices of the profileplyr object will be the same and will be colored as specified here. The character and numeric vector inputs must be either two or three elements in length (denoting color progressions - three elements will give a middle color break), and each element must be a character string or number that points to a color. By default, numeric vectors use the colors in palette(), however this can be expanded with other R color lists(e.g. colors()). If this argument is a list then it's length must equal the number of matrices/samples that exist in the input profileplyr object. The components of the list can be either a numeric vector, character vector, or color function (they do not have to all be the same type of specification). Each element in the list will be the color mapping to the corresponding element in the profileplyr object.}

\item{matrices_pos_line}{A logical for whether to draw a vertical line(s) at the position of the target (for both a single point or a window). Default is true.}

\item{matrices_pos_line_gp}{Graphics parameters for the vertical position lines. Should be set with the gpar() function from the grid() package.}

\item{matrices_show_heatmap_legend}{Logical denoting whether legends for all the heatmaps showing signal over the ranges/matrices should be shown. Default is FALSE.}

\item{matrices_column_title_gp}{Graphics parameters for the titles on top of each range/matrix (set by 'sample_names' argument or the names of each matrix by default). Should be set with the gpar() function from the grid() package.}

\item{matrices_axis_name_gp}{Graphics parameters for the text on the x-axis of each matrix heatmap. Should be set with the gpar() function from the grid() package.}

\item{group_anno_color}{This will specify colors for the grouping column if the 'include_group_annotation' argument is set to TRUE. Since the group column of the range metadata should always be a discrete value, this should be either a numeric vector or character vector with color names. By default, numeric vectors use the colors in palette(), however this can be expanded with other R color lists(e.g. colors()). The length of this vector must equal the number of groups.}

\item{group_anno_width}{A numeric value that is used to will set the width of the column bar (in mm using the unit() function from the grid package) for the grouping annotation column.}

\item{group_anno_row_title_gp}{Graphics parameters for the labels of the groups on the side of the heatmap. Should be set with the gpar() function from the grid() package.}

\item{group_anno_column_names_gp}{Graphics parameters for the label of the grouping annotation column. Should be set with the gpar() function from the grid() package.}

\item{extra_anno_color}{This will specify colors for the annotation columns added by the 'extra_annotation_columns' argument. This must be a list that is of equal length to the 'extra_annotation_columns' argument. Each element of this list will be used to specify the color scheme for the corresponding element of the 'extra_annotation_columns' vector. If an element is NULL, the default colors will be used for the column annotation. For a column with discrete variables this will typically be a vector of numbers or a vector of color names. By default, numeric vectors use the colors in palette(), however this can be expanded with other R color lists(e.g. colors()). For columns with continuous variables, this can also be a a vector of numbers or a vector of color names to signify the color progression, or it can be color mapping function using colorRamp2() from the circlize package.}

\item{extra_anno_top_annotation}{This is a logical vector that determines whether annotation plots are shown on top of the heatmaps for the extra annotations. This must either be a length of 1, in which case all of the heatamps will abide by this value. Otherwise this must be a vector of equal length to the 'extra_annotation_columns' argument and the elements of this vector will correspond to the equvalent elements in 'extra annotation_columns'}

\item{extra_anno_width}{This will set the width of the individual extra annotation columns on the right side of the figure. This must be a numeric vector with each element setting the width for the corresponding element in the 'extra_annotation_columns' argument.}

\item{only_extra_annotation_columns}{If set to TRUE, only the heatmaps representing the extra annotation columns whill be shown, and the range based heatmaps from the assay matricies will be excluded.}

\item{gap}{The size of the gap between heatmaps and annotations. Only relevant if return_ht_list = FALSE}

\item{genes_to_label}{A character vector of gene symbols that should match character strings in the 'SYMBOL' column that results from either 'annotateRanges' or 'annotateRanges_great'. Genes that are both in this vector and in the 'SYMBOL' column will be labeled on the heatmap.}

\item{gene_label_font_size}{The size of the text for the labels for genes specified in 'genes_to_label' argument.}
}
\value{
By default a customized version of a heatmap from EnrichedHeatmap, if return_ht_list = TRUE then a heatmap list is returned that can be modified and then entered as an input for the \code{\link[EnrichedHeatmap]{EnrichedHeatmap}} function
}
\description{
export a profileplyr object directly to an object of the EnrichedHeatmap class
}
\details{
Takes a profileplyr object and generated heatmap that can be annotated by group or by range metadata columns of the profileplyr object
}
\examples{
example <- system.file("extdata", "example_deepTools_MAT", package = "profileplyr") 
object <- import_deepToolsMat(example)

generateEnrichedHeatmap(object, include_group_annotation = FALSE)
}
